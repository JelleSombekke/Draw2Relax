<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Draw2Relax</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            pointer-events: none;
        }
        #glow-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            pointer-events: none;
        }
        #draw-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #toolbar {
            pointer-events: none;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0);
            padding: 8px;
            border-radius: 8px;
        }
        button {
            pointer-events: auto;
            font-size: 16px;
            margin-right: 10px;
        }

        .button-styled {
            align-items: center;
            appearance: none;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 24px;
            border-style: none;
            box-shadow: rgba(0, 0, 0, .2) 0 3px 5px -1px,
                        rgba(0, 0, 0, .14) 0 6px 10px 0,
                        rgba(0, 0, 0, .12) 0 1px 18px 0;
            box-sizing: border-box;
            color: #3c4043;
            cursor: pointer;
            display: inline-flex;
            fill: currentcolor;
            font-family: "Google Sans", Roboto, Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            height: 48px;
            justify-content: center;
            letter-spacing: .25px;
            line-height: normal;
            max-width: 100%;
            overflow: visible;
            padding: 2px 24px;
            position: relative;
            text-align: center;
            text-transform: none;
            transition: box-shadow 280ms cubic-bezier(.4, 0, .2, 1),
                        opacity 15ms linear 30ms,
                        transform 270ms cubic-bezier(0, 0, .2, 1) 0ms;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            width: auto;
            will-change: transform, opacity;
            z-index: 0;
        }

        .button-styled:hover {
        background: #F6F9FE;
        color: #174ea6;
        }

        .button-styled:active {
        box-shadow: 0 4px 4px 0 rgb(60 64 67 / 30%), 0 8px 12px 6px rgb(60 64 67 / 15%);
        outline: none;
        }

        .button-styled:not(:disabled) {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        .button-styled:not(:disabled):hover {
        box-shadow: rgba(60, 64, 67, .3) 0 2px 3px 0, rgba(60, 64, 67, .15) 0 6px 10px 4px;
        }

        .button-styled:not(:disabled):focus {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        .button-styled:not(:disabled):active {
        box-shadow: rgba(60, 64, 67, .3) 0 4px 4px 0, rgba(60, 64, 67, .15) 0 8px 12px 6px;
        }

        .button-styled:disabled {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        body.drawing-mode button,
        body.drawing-mode .button-styled {
            pointer-events: none;
            cursor: default !important;
            background: rgba(255, 255, 255, 0.75) !important;
            color: #3c4043 !important;
            box-shadow: rgba(0, 0, 0, .2) 0 1px 1px -1px,
                        rgba(0, 0, 0, .14) 0 2px 4px 0,
                        rgba(0, 0, 0, .12) 0 0px 12px 0 !important;
        }

        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 20;
        }

        .spinner-border {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        #toggle-mode-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
            z-index: 20;
        }

        #sensor-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 20;
        }

        #status-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
            background-color: red; /* Default: inactive */
        }

        #toggle-fullscreen-btn {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
            z-index: 20;
        }

        body.drawing-mode #toggle-mode-btn,
        body.drawing-mode #sensor-status,
        body.drawing-mode #toggle-fullscreen-btn {
            pointer-events: none;
            cursor: default !important;
            background: rgba(255, 255, 255, 0.75) !important;
            color: #3c4043 !important;
            box-shadow: 0 0 6px rgba(0,0,0,0.1) !important;
        }

        #qr-modal {
            display: none; /* hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 9999;

            display: flex;
            align-items: center;
            justify-content: center;
        }

        #qr-modal > div {
            background: white;
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 90%;
        }

        #qr-modal img {
            max-width: 300px;
            margin: 10px auto;
        }

        #palette-dropdown {
            pointer-events: auto;
            display: block;
            margin-top: 8px;
            width: fit-content;
            }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-options {
            display: none;
            position: absolute;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 8px 0;
            z-index: 1000;
            min-width: 160px;
            top: 100%;
            left: 0;
            }

        .dropdown-options.open {
            display: block;
        }

        .palette-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
        }

        .palette-option:hover {
            background-color: #f0f0f0;
        }

        .palette-colors {
            display: flex;
            margin-left: auto;
        }

        .palette-swatch {
            width: 16px;
            height: 16px;
            margin-left: 4px;
            border-radius: 50%;
            border: 1px solid #ccc;
        }


    </style>
</head>
<body>

<canvas id="background-canvas"></canvas>
<canvas id="glow-canvas"></canvas>
<canvas id="draw-canvas"></canvas>

<div id="toolbar">
    <button class="button-styled" role="button" onclick="clearCanvas()">Clear</button>
    <button class="button-styled" role="button" onclick="undo()">Undo</button>
    <button class="button-styled" role="button" onclick="submitDrawing()">Submit</button>
    <button class="button-styled" role="button" onclick="simulateBreathing()">Simulate</button>
    <button id="show-qr-btn" class="button-styled" style="display:none;">Connect device</button>

    <div id="palette-dropdown" class="dropdown">
        <button id="palette-toggle-btn" class="button-styled">Palette: <span id="selected-palette">Blues</span></button>
        <div id="dropdown-options" class="dropdown-options"></div>
    </div>

</div>

<button id="toggle-mode-btn">Mousepad Mode: OFF</button>

<button id="toggle-fullscreen-btn" onclick="toggleFullscreen();">Fullscreen Off</button>

<div id="sensor-status">
    <span id="status-text">Breathing Sensor Inactive</span>
    <span id="status-light"></span>
</div>

<div id="spinner" style="
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    background: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 10px;
    z-index: 999;
">
    Processing...
</div>

<!-- QR Modal -->
<div id="qr-modal" style="display:none;">
    <div>
      <h3>Scan this QR with your device</h3>
      <img id="qr-image" src="" alt="QR Code"/>
      <br/>
      <button onclick="closeQRModal()">Close</button>
    </div>
</div>

<script>
let laptopIP = null;

// Canvases setups
function setupCanvas(canvas, dpr) {
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Set canvas style size (CSS pixels)
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    // Set actual canvas size (scaled for resolution)
    canvas.width = width * dpr;
    canvas.height = height * dpr;

    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return ctx;
}

const dpr = window.devicePixelRatio || 1;
let canvas = document.getElementById('draw-canvas');
let ctx = setupCanvas(canvas, dpr);
let glowCanvas = document.getElementById('glow-canvas');
let glowCtx = setupCanvas(glowCanvas, dpr);
let bgCanvas = document.getElementById('background-canvas');
let bgCtx = setupCanvas(bgCanvas, dpr);
let offscreenCanvas = document.createElement('canvas');
let offscreenCtx = setupCanvas(offscreenCanvas, dpr);

const paletteToggleBtn = document.getElementById("palette-toggle-btn");
const dropdownOptions = document.getElementById("dropdown-options");
const selectedText = document.getElementById("selected-palette");

const palettes = {
    blues: {
        background: [[180, 210, 255], [100, 150, 255], [130, 190, 255], [160, 220, 255]],
        glow:       [[100, 130, 255], [80, 120, 250], [60, 100, 220], [40, 80, 200]]
    },
    reds: {
        background: [[255, 150, 150], [255, 100, 100], [200, 70, 70], [230, 120, 120]],
        glow:       [[255, 100, 180], [200, 50, 130], [150, 30, 100], [220, 90, 150]]
    },
    purples: {
        background: [[220, 200, 255], [200, 180, 255], [160, 130, 255], [120, 90, 220]],
        glow:       [[160, 140, 240], [120, 100, 200], [90, 70, 180], [60, 40, 150]]
    },
    teals: {
        background: [[200, 255, 240], [150, 230, 220], [100, 200, 190], [60, 170, 160]],
        glow:       [[140, 255, 220], [100, 220, 200], [60, 180, 160], [40, 140, 130]]
    },
    ambers: {
        background: [[255, 235, 180], [255, 210, 120], [255, 180, 60], [220, 140, 20]],
        glow:       [[255, 200, 100], [255, 170, 80], [230, 140, 40], [200, 110, 20]]
    },
    forest: {
        background: [[200, 255, 200], [160, 220, 160], [120, 180, 120], [80, 140, 80]],
        glow:       [[140, 230, 140], [100, 190, 100], [70, 150, 70], [50, 110, 50]]
    }
};

let chosenPalette = 'blues';
let paletteDropdownOpen = false;
let colorCounter = 0;
let startColor = [180, 210, 255];
let prevColor =[180, 210, 255];
let startGlowColor = [100, 130, 255];
let prevGlowColor = [100, 130, 255];
let currentColorIndex = 0;

// Populate dropdown options
Object.entries(palettes).forEach(([name, colors]) => {
  const option = document.createElement("div");
  option.className = "palette-option";
  option.dataset.palette = name;
  option.innerHTML = `
    ${name.charAt(0).toUpperCase() + name.slice(1)}
    <div class="palette-colors">
      ${colors.background.map(([r, g, b]) =>
        `<div class="palette-swatch" style="background: rgb(${r},${g},${b})"></div>`
      ).join('')}
    </div>
  `;

  option.addEventListener("click", () => {
    chosenPalette = name;
    selectedText.textContent = name.charAt(0).toUpperCase() + name.slice(1);
    startColor = palettes[name].background[0];
    startGlowColor = palettes[name].glow[0];
    bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgR = Math.round(startColor[0])
    bgG = Math.round(startColor[1])
    bgB = Math.round(startColor[2])
    bgCtx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    closeDropdown();
  });

  dropdownOptions.appendChild(option);
});

// Toggle dropdown
paletteToggleBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (paletteToggleBtn.disabled) return;

  paletteDropdownOpen = !paletteDropdownOpen;
  dropdownOptions.classList.toggle("open", paletteDropdownOpen);
});

document.addEventListener("click", () => closeDropdown());
document.addEventListener("touchstart", (e) => {
  if (paletteDropdownOpen && !dropdownOptions.contains(e.target) && e.target !== paletteToggleBtn) {
    closeDropdown();
  }
});

function closeDropdown() {
  paletteDropdownOpen = false;
  dropdownOptions.classList.remove("open");
}


const submitBtn = document.querySelector('button[onclick="submitDrawing()"]');
const clearBtn = document.querySelector('button[onclick="clearCanvas()"]');
const undoBtn = document.querySelector('button[onclick="undo()"]');
const spinnerBlock = document.getElementById('spinner')
const simulateBtn = document.querySelector('button[onclick="simulateBreathing()"]');
const toggleBtn = document.getElementById("toggle-mode-btn")
const connectBtn = document.getElementById('show-qr-btn');
const sensorStatus = document.getElementById('sensor-status');
const qrBtn = document.getElementById('show-qr-btn');
const fulllscreenBtn = document.getElementById('toggle-fullscreen-btn');

let framePaths = []; 
let drawing = false;
let isDrawingDisabled = false;
let mousepadMode = false;
let currentPath = [];
let submitted = false;
let paths = [];
let animationFrameId = null;
let breathingSensorActive = false;
let previousBreathingValue = 0;
let currentBreathingValue = 0;
let global_index = 0
let isAnimating = false;
let isAnimatingBackground = false;
let breathingIntervalId = null;
let simulationIntervalId = null;
let breathingDirection = "up"; // or "down"
let previousValues = [];
const maxWindowSize = 20;
let peakDetected = false;
let valleyDetected = false;
let frameImages = [];
let blackPixels = null;
let inhaleMax = null;
let exhaleMin = null;

const toggleModeBtn = document.getElementById('toggle-mode-btn');
toggleModeBtn.addEventListener('click', () => {
    mousepadMode = !mousepadMode;
    toggleModeBtn.textContent = mousepadMode ? "Mousepad Mode: ON" : "Mousepad Mode: OFF";
});

window.addEventListener('DOMContentLoaded', () => {
  if (isLaptop()) {
    qrBtn.addEventListener('click', showQRModal);
    toggleBtn.style.display = 'inline-block';
    qrBtn.style.display = 'inline-block';
    paletteToggleBtn.style.display = 'inline-block';
    simulateBtn.style.display = 'inline-block';
  } else {
    toggleBtn.style.display = 'none';
    qrBtn.style.display = 'none';
    paletteToggleBtn.style.display = 'none';
    simulateBtn.style.display = 'none';
    sensorStatus.style.display = 'none';
  }
});

window.addEventListener("beforeunload", (event) => {
    // Send a background POST to clear frames
    navigator.sendBeacon('/clear-frames');

    colorCounter = 0;
    startColor = [255, 255, 255];
    prevColor = [255, 255, 255];
    startGlowColor = [255, 255, 255];
    prevGlowColor = [255, 255, 255];
    blackPixels = null;
    frameImages = [];


    if (breathingIntervalId !== null) {
        clearInterval(breathingIntervalId);
        breathingIntervalId = null;
    }

    if (simulationIntervalId !== null) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }

    if (breathingSensorActive){
        fetch('/stop-sensor', {
            method: 'POST',
            body: JSON.stringify({}),
            headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(response => {
            breathingSensorActive = false;
            updateSensorStatus();
        })
        .catch(err => {
            console.error('Error during sensor deactivating:', err);
            alert("Something went wrong. Please try again.");
        })
    }
});
// Mouse
canvas.addEventListener('mousedown', startDrawing);
window.addEventListener('mousemove', drawMove);
window.addEventListener('mouseup', stopDrawing);

// Touch
canvas.addEventListener('touchstart', startDrawing, { passive: false });
canvas.addEventListener('touchmove', drawMove, { passive: false });
canvas.addEventListener('touchend', stopDrawing);

document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement) {
    fulllscreenBtn.textContent = 'Fullscreen Off';
  } else {
    fulllscreenBtn.textContent = 'Fullscreen On';
  }
});

// Check device logic
function isIOS() {
  const ua = navigator.userAgent || navigator.vendor || window.opera;
  return /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
}

function isIPadOS() {
  return (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}

function isLaptop() {
  // Laptop = Not iOS, not iPadOS, not any mobile device
  return !isIOS() && !isIPadOS() && !/Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}


// Drawing logic
function getPointFromEvent(e) {
    if (e.touches) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else {
        return { x: e.clientX, y: e.clientY };
    }
}

function startDrawing(e) {
    if (isDrawingDisabled) return;
    const point = getPointFromEvent(e);

    if (mousepadMode) {
        if (drawing) {
            drawing = false;
            if (currentPath.length > 0) {
                paths.push(currentPath);
                currentPath = [];
            }
            submitBtn.disabled = false;
            clearBtn.disabled = false;
            undoBtn.disabled = false;
            simulateBtn.disabled = false;
            connectBtn.disabled = false;
            paletteToggleBtn.disabled = false;
            document.body.classList.remove('drawing-mode');
        } else {
            drawing = true;
            currentPath = [point];
            submitBtn.disabled = true;
            clearBtn.disabled = true;
            undoBtn.disabled = true;
            simulateBtn.disabled = true;
            connectBtn.disabled = true;
            paletteToggleBtn.disabled = true;
            document.body.classList.add('drawing-mode');
        }
    } else {
        drawing = true;
        currentPath = [point];
        document.body.classList.add('drawing-mode');
    }

    e.preventDefault();
}

function stopDrawing(e) {
    if (isDrawingDisabled) return;
    if (!mousepadMode && drawing) {
        drawing = false;
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;
        document.body.classList.remove('drawing-mode');
        if (currentPath.length > 0) {
            paths.push(currentPath);
            currentPath = [];
        }
    }
    e.preventDefault();
}

function drawMove(e) {
    if (isDrawingDisabled || !drawing) return;
    const point = getPointFromEvent(e);
    currentPath.push(point);

    submitBtn.disabled = true;
    clearBtn.disabled = true;
    undoBtn.disabled = true;
    simulateBtn.disabled = true;
    connectBtn.disabled = true;
    paletteToggleBtn.disabled = true;

    if (currentPath.length > 1) {
        const prev = currentPath[currentPath.length - 2];
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
    }

    e.preventDefault();
}


// Breathing Data Handling
function fetchBreathingData() {
    fetch('/get-breathing-data')
        .then(res => res.json())
        .then(data => {
            const breathingValue = data.breathing_value;

            // Keep original direction logic
            const direction = (breathingValue > previousBreathingValue) ? "up"
                             : (breathingValue < previousBreathingValue) ? "down"
                             : breathingDirection;

            breathingDirection = direction;
            previousBreathingValue = breathingValue;

            // Normalize and map to frame index
            // const minVal = 80
            const minVal = exhaleMin;
            // const maxVal = 130
            const maxVal = inhaleMax;
            const normalized = Math.max(0, Math.min(1, (breathingValue - minVal) / (maxVal - minVal)));
            const index = Math.floor(normalized * (framePaths.length - 1));
            console.log("Frame index", index, "Breathing value", breathingValue, "minVal", minVal, "maxVal", maxVal, "framePaths length:", framePaths.length)
            showFrameAtIndex(index);

            // Peak/trough detection
            previousValues.push(breathingValue);
            if (previousValues.length > maxWindowSize) previousValues.shift();

            if (previousValues.length === maxWindowSize) {
                const midIndex = Math.floor(maxWindowSize / 2);
                const midValue = previousValues[midIndex];

                const isPeak = previousValues.every((v, i) => i === midIndex || v < midValue);
                const isValley = previousValues.every((v, i) => i === midIndex || v > midValue);

                if (isPeak && !peakDetected) {
                    peakDetected = true;
                    valleyDetected = false;
                    updateColorCycle(); // Inhale peak
                } else if (isValley && !valleyDetected) {
                    valleyDetected = true;
                    peakDetected = false;
                    updateColorCycle(); // Exhale bottom
                }
            }

        })
        .catch(err => console.error('Error fetching breathing data:', err));
}

async function getBreathingSample() {
    return fetch('/sample-breathing-data')
        .then(res => res.json())
        .then(data => {
            const val = data.breathing_value;
            console.log('Sampled breathing value:', val);
            return val;
        })
        .catch(err => {
            console.error('Error fetching breathing data:', err);
            return null;
        });
}

function getAverageBreathingSample(sampleCount = 100, interval = 50) {
    return new Promise((resolve) => {
        const values = [];
        const timer = setInterval(async () => {
            const val = await getBreathingSample();
            if (typeof val === 'number') {
                values.push(val);
            }
            if (values.length >= sampleCount) {
                clearInterval(timer);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;
                resolve(avg);
            }
        }, interval);
    });
}

async function calibrateBreathingSensor() {
    const instructionEl = document.createElement('div');
    Object.assign(instructionEl.style, {
        position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.85)', color: 'white',
        fontSize: '2rem', textAlign: 'center', zIndex: '10000', padding: '1rem',
    });

    const message = document.createElement('div');
    instructionEl.appendChild(message);
    document.body.appendChild(instructionEl);

    function updateText(text) {
        message.textContent = text;
    }

    function wait(ms) {
        return new Promise(res => setTimeout(res, ms));
    }

    updateText("Please fully inhale and hold...");
    await wait(6000);
    let inhale = await getAverageBreathingSample(100, 50);
    await wait(1000);

    updateText("Now fully exhale and hold...");
    await wait(6000);
    let exhale = await getAverageBreathingSample(100, 50);
    await wait(1000);

    if (exhale >= (inhale - 20)) {
        exhale = inhale - 20;
    };

    inhaleMax = inhale;
    exhaleMin = exhale;

    console.log("Calibration complete — Inhale Max:", inhale, "Exhale Min:", exhale);
    updateText("Calibration complete.");
    await wait(1500);

    document.body.removeChild(instructionEl);
}


// Canvas Handling
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    paths = [];
    currentPath = [];

    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
    glowCtx.clearRect(0, 0, canvas.width, canvas.height);

    if (breathingIntervalId !== null) {
        clearInterval(breathingIntervalId);
        breathingIntervalId = null;
    }
    if (simulationIntervalId !== null) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }

    submitBtn.style.display = 'inline-block';
    undoBtn.style.display = 'inline-block';
    fulllscreenBtn.style.display = "inline-block";
    if (isLaptop()) {
        toggleBtn.style.display = "inline-block";
        simulateBtn.style.display = 'inline-block';
        connectBtn.style.display = "inline-block";
        paletteToggleBtn.style.display = "inline-block";
    }
    fetch('/clear-frames', {
        method: 'POST'
    })
    .then(res => {
        if (!res.ok) throw new Error('Failed to clear server frames');
    })
    .catch(err => {
        console.error('Error clearing frames:', err);
    });

    submitted = false;
    isDrawingDisabled = false;
    isAnimatingBackground = false;
    colorCounter = 0;
    startColor = [255, 255, 255];
    prevColor = [255, 255, 255];
    startGlowColor = [255, 255, 255];
    prevGlowColor = [255, 255, 255];
    blackPixels = null;
    frameImages = [];

    if (breathingSensorActive){
        fetch('/stop-sensor', {
            method: 'POST',
            body: JSON.stringify({}),
            headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(response => {
            breathingSensorActive = false;
            updateSensorStatus();
        })
        .catch(err => {
            console.error('Error during sensor deactivating:', err);
            alert("Something went wrong. Please try again.");
    })
    }
}

function undo() {
    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animateBackgroundColor([255, 255, 255], [255, 255, 255], 1)
    }
    
    if (paths.length > 0) {
        paths.pop(); // Remove last stroke
        redrawAll();
    }
    

    if (submitted) {
        fetch('/clear-frames', {
            method: 'POST'
        })
        .then(res => {
            if (!res.ok) throw new Error('Failed to clear server frames');
        })
        .catch(err => {
            console.error('Error clearing frames:', err);
        });

        submitted = false;
        isDrawingDisabled = false;
        colorCounter = 0;
        startColor = [255, 255, 255];
        prevColor = [255, 255, 255];
        startGlowColor = [255, 255, 255];
        prevGlowColor = [255, 255, 255];
        blackPixels = null;
        frameImages = [];
    }
}

function redrawAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'black';

    for (let path of paths) {
        for (let i = 1; i < path.length; i++) {
            ctx.beginPath();
            ctx.moveTo(path[i - 1].x, path[i - 1].y);
            ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
        }
    }

    bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgR = Math.round(startColor[0])
    bgG = Math.round(startColor[1])
    bgB = Math.round(startColor[2])
    bgCtx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
}

// Preloading Animation Frames
function preloadFrames() {
    return Promise.all(frameImages = framePaths.map((base64, i) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = `data:image/png;base64,${base64}`;

            img.onload = () => {
                // Draw at natural image size to preserve pixel integrity
                offscreenCanvas.width = img.width;
                offscreenCanvas.height = img.height;
                offscreenCtx.drawImage(img, 0, 0, img.width, img.height);

                const imageData = offscreenCtx.getImageData(0, 0, img.width, img.height);
                const minStep = 6;
                const maxStep = 2;
                const totalFrames = framePaths.length;

                // Linearly interpolate step size
                const sampleStep = Math.round(
                    maxStep - ((maxStep - minStep) * (i / (totalFrames - 1)))
                );

                const blackPixels = [];

                for (let y = 0; y < img.height; y += sampleStep) {
                    for (let x = 0; x < img.width; x += sampleStep) {
                        const idx = (y * img.width + x) * 4;
                        const r = imageData.data[idx];
                        const g = imageData.data[idx + 1];
                        const b = imageData.data[idx + 2];
                        const a = imageData.data[idx + 3];

                        if (r < 50 && g < 50 && b < 50 && a > 50) {
                            blackPixels.push({ x, y });
                        }
                    }
                }

                img.blackPixelsCache = blackPixels;
                resolve(img);
            };
        });
    }));
}


// Submit pipeline and Simulate pipeline
async function submitDrawing() {
    if (!isLaptop()) {
        sendDrawingToLaptop();
        alert("Drawing sent to laptop for processing.");
        return;
    }

    const dataURL = canvas.toDataURL('image/png');
    submitted = true;

    // Disable UI
    submitBtn.disabled = true;
    clearBtn.disabled = true;
    undoBtn.disabled = true;
    simulateBtn.disabled = true;
    connectBtn.disabled = true;
    paletteToggleBtn.disabled = true;
    isDrawingDisabled = true;
    spinnerBlock.style.display = 'block';

    try {
        // Start processing immediately
        const processingPromise = fetch('/process', {
            method: 'POST',
            body: JSON.stringify({ image: dataURL }),
            headers: { 'Content-Type': 'application/json' }
        })
            .then(res => res.json())
            .then(response => {
                framePaths = response.frames;
                return preloadFrames();
            })
            .then(loadedImages => {
                frameImages = loadedImages;
            });

        // Wait for the sensor to be activated before calibration
        await fetch('/run-sensor', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
        });

        breathingSensorActive = true;
        updateSensorStatus();

        // Now calibrate the sensor (in parallel with processing)
        const calibrationPromise = calibrateBreathingSensor();

        // Wait for both to finish
        await Promise.all([processingPromise, calibrationPromise]);

        // UI after everything is ready
        spinnerBlock.style.display = 'none';
        submitBtn.style.display = 'none';
        undoBtn.style.display = 'none';
        toggleBtn.style.display = "none";
        simulateBtn.style.display = "none";
        connectBtn.style.display = "none";
        paletteToggleBtn.style.display = "none";
        fulllscreenBtn.style.display = "none";

        showFrameAtIndex(0);
        updateColorCycle();

        // Start breathing data updates
        breathingIntervalId = setInterval(fetchBreathingData, 50);

    } catch (err) {
        console.error('Error during setup:', err);
        alert("Something went wrong. Please try again.");
    } finally {
        // Re-enable controls
        spinnerBlock.style.display = 'none';
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;
        isDrawingDisabled = false;
    }
}

function simulateBreathing() {
    const dataURL = canvas.toDataURL('image/png');
    submitted = true;

    submitBtn.disabled = true;
    clearBtn.disabled = true;
    undoBtn.disabled = true;
    simulateBtn.disabled = true;
    connectBtn.disabled = true;
    paletteToggleBtn.disabled = true;

    isDrawingDisabled = true;
    spinnerBlock.style.display = 'block';

    fetch('/process', {
        method: 'POST',
        body: JSON.stringify({ image: dataURL }),
        headers: { 'Content-Type': 'application/json' }
    })
    .then(res => res.json())
    .then(response => {
        framePaths = response.frames;
        return preloadFrames();
    })
    .then(loadedImages => {
        frameImages = loadedImages;

        spinnerBlock.style.display = 'none';
        submitBtn.style.display = 'none';
        undoBtn.style.display = 'none';
        simulateBtn.style.display = 'none';
        toggleBtn.style.display = "none";
        connectBtn.style.display = "none";
        paletteToggleBtn.style.display = "none";
        fulllscreenBtn.style.display = "none";

        showFrameAtIndex(0);
        updateColorCycle();

        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;

        // --- Simulation Setup ---
        const n_frames = framePaths.length;
        const duration_sec = 300;
        const sampling_rate = 200;
        const total_samples = duration_sec * sampling_rate;

        const breathing_rate_per_min = 12;
        const breath_cycles = (breathing_rate_per_min / 60) * duration_sec;

        const minVal = 70;
        const maxVal = 160;

        const t_interp = Array.from({ length: total_samples }, (_, i) => i / sampling_rate);
        const freq = breath_cycles / duration_sec; // cycles per second
        const rr_interp = t_interp.map(t => {
            const cycle_duration = 1 / freq;
            const phase = t % cycle_duration;

            const inhale_time = 0.4 * cycle_duration;
            const hold_in_time = 0.1 * cycle_duration;
            const exhale_time = 0.4 * cycle_duration;
            const hold_out_time = 0.1 * cycle_duration;

            if (phase < inhale_time) {
                // Inhale (ramp up)
                return phase / inhale_time;
            } else if (phase < inhale_time + hold_in_time) {
                // Hold after inhale
                return 1;
            } else if (phase < inhale_time + hold_in_time + exhale_time) {
                // Exhale (ramp down)
                return 1 - ((phase - inhale_time - hold_in_time) / exhale_time);
            } else {
                // Hold after exhale
                return 0;
            }
        });

        const min = Math.min(...rr_interp);
        const max = Math.max(...rr_interp);
        const rr_norm = rr_interp.map(v => (v - min) / (max - min)); // Normalize to [0, 1]

        let i = 0;
        const delay = 2000 / sampling_rate;

        previousBreathingValue = 0;
        previousValues = [];
        peakDetected = false;
        valleyDetected = false;

        simulationIntervalId = setInterval(() => {
            if (i >= rr_norm.length) {
                clearInterval(simulationIntervalId);
                simulationIntervalId = null;
                console.log("Done with simulation");
                return;
            }

            const normalized = rr_norm[i];
            const breathingValue = normalized * (maxVal - minVal) + minVal;

            const direction = (breathingValue > previousBreathingValue) ? "up"
                             : (breathingValue < previousBreathingValue) ? "down"
                             : breathingDirection;
            breathingDirection = direction;
            previousBreathingValue = breathingValue;

            const index = Math.floor(normalized * (n_frames - 1));
            showFrameAtIndex(index);

            // Peak/trough detection
            previousValues.push(breathingValue);
            if (previousValues.length > maxWindowSize) previousValues.shift();

            if (previousValues.length === maxWindowSize) {
                const lastIndex = maxWindowSize - 1;
                const lastValue = previousValues[lastIndex];

                const isPeak = lastValue === 160 && previousValues.every((v, i) => i === lastIndex || v < lastValue);
                const isValley = lastValue === 70 && previousValues.every((v, i) => i === lastIndex || v > lastValue);

                if (isPeak && !peakDetected) {
                    peakDetected = true;
                    valleyDetected = false;
                    updateColorCycle(); // Inhale peak
                } else if (isValley && !valleyDetected) {
                    valleyDetected = true;
                    peakDetected = false;
                    updateColorCycle(); // Exhale bottom
                }
            }

            i++;
        }, delay);
    })
    .catch(err => {
        console.error('Error during image processing:', err);
        spinnerBlock.style.display = 'none';
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;

        isDrawingDisabled = false;
        alert("Something went wrong. Please try again.");
    });
}


// Animation logic 
function showFrameAtIndex(targetIndex) {
    if (!frameImages.length || targetIndex < 0 || targetIndex >= frameImages.length) return;
    if (isAnimating || targetIndex === global_index) return;

    isAnimating = true;

    const step = (targetIndex > global_index) ? 1 : -1;

    function animateStep() {
        global_index += step;

        const img = frameImages[global_index];
        if (!img.complete) {
            // If image isn't loaded yet, wait and retry
            setTimeout(animateStep, 5);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
        // console.log("Image index:", global_index);

        drawGlowForFrame(global_index)
        animateBackgroundColor(prevColor, startColor, 1000);

        if (global_index !== targetIndex) {
            setTimeout(animateStep, 10); // smooth step
        } else {
            isAnimating = false;
        }
    }

    animateStep();
}

function getDoodleLength() {
    let length = 0;
    paths.forEach(path => {
        for (let i = 1; i < path.length; i++) {
            const dx = path[i].x - path[i - 1].x;
            const dy = path[i].y - path[i - 1].y;
            length += Math.sqrt(dx * dx + dy * dy);
        }
    });
    return length;
}

function updateColorCycle() {
    const paletteObj = palettes[chosenPalette];
    const bgPalette = paletteObj.background;
    const glowPalette = paletteObj.glow;

    const blendFactor = 0.25;

    const nextIndex = (currentColorIndex + 1) % bgPalette.length;
    const nextColor = bgPalette[nextIndex];
    const nextGlowColor = glowPalette[nextIndex];

    prevColor = [...startColor];
    prevGlowColor = [...startGlowColor];

    // Blend without rounding
    startColor = startColor.map((c, i) =>
        c * (1 - blendFactor) + nextColor[i] * blendFactor
    );

    startGlowColor = startGlowColor.map((c, i) =>
        c * (1 - blendFactor) + nextGlowColor[i] * blendFactor
    );

    // Compute squared distance to avoid rounding errors
    const colorDistanceSq = startColor.reduce((sum, c, i) => sum + Math.pow(c - nextColor[i], 2), 0);
    const glowDistanceSq = startGlowColor.reduce((sum, c, i) => sum + Math.pow(c - nextGlowColor[i], 2), 0);

    // Threshold (squared distance): 1^2 = 1
    if (colorDistanceSq < 1 && glowDistanceSq < 1) {
        currentColorIndex = nextIndex;
        console.log("Advanced to color index:", currentColorIndex);
    }

    console.log(
        "startColor:",
        startColor.map(Math.round),
        "→ target:",
        nextColor
    );
}

function drawGlowForFrame(targetIndex, radius = 10, t = 1) {
    const img = frameImages[targetIndex];
    const blackPixels = img.blackPixelsCache;
    if (!blackPixels) return;
    

    const glowR = Math.round(prevGlowColor[0] + (startGlowColor[0] - prevGlowColor[0]) * t);
    const glowG = Math.round(prevGlowColor[1] + (startGlowColor[1] - prevGlowColor[1]) * t);
    const glowB = Math.round(prevGlowColor[2] + (startGlowColor[2] - prevGlowColor[2]) * t);
    const glowColor = [glowR, glowG, glowB];

    glowCtx.clearRect(0, 0, canvas.width, canvas.height);
    glowCtx.save();
    glowCtx.globalAlpha = 0.9;
    radius = radius * (targetIndex / (framePaths.length - 1)) + 5

    const adjustedRadius = radius * dpr;
    const glowStamp = createGlowStamp(glowColor, adjustedRadius);

    const offsetX = Math.sin(1 * 0.5) * 10;
    const offsetY = Math.cos(1 * 0.5) * 10;

    blackPixels.forEach(({ x, y }) => {
        const sx = (x + offsetX) / dpr;
        const sy = (y + offsetY) / dpr;

        glowCtx.drawImage(glowStamp, sx - adjustedRadius, sy - adjustedRadius);
    });

    glowCtx.restore();
}

function createGlowStamp(color, radius) {
    const size = radius * 2;
    const glowstampCanvas = document.createElement('canvas');
    glowstampCanvas.width = glowstampCanvas.height = size;
    const glowstampCtx = glowstampCanvas.getContext('2d');

    const [r, g, b] = color;
    const gradient = glowstampCtx.createRadialGradient(
        radius, radius, 0,
        radius, radius, radius
    );
    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

    glowstampCtx.fillStyle = gradient;
    glowstampCtx.fillRect(0, 0, size, size);

    return glowstampCanvas;
}

function animateBackgroundColor(startColor, endColor, duration = 5000) {
    let startTime = null;
    isAnimatingBackground = true;

    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    function animate(time) {
        if (!isAnimatingBackground) return;
        if (!startTime) startTime = time;

        const elapsed = time - startTime;
        const t = Math.min(elapsed / duration, 1);

        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);

        // Interpolate background color normally
        const bgR = Math.round(startColor[0] + (endColor[0] - startColor[0]) * t);
        const bgG = Math.round(startColor[1] + (endColor[1] - startColor[1]) * t);
        const bgB = Math.round(startColor[2] + (endColor[2] - startColor[2]) * t);

        // Fill background with interpolated color
        bgCtx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

        if (t < 1) {
            animationFrameId = requestAnimationFrame(animate);
        } else {
            isAnimatingBackground = false;
        }
    }
    animationFrameId = requestAnimationFrame(animate);
}

function updateSensorStatus() {
    const statusText = document.getElementById("status-text");
    const statusLight = document.getElementById("status-light");

    if (breathingSensorActive) {
        statusText.textContent = "Breathing Sensor Active";
        statusLight.style.backgroundColor = "green";
    } else {
        statusText.textContent = "Breathing Sensor Inactive";
        statusLight.style.backgroundColor = "red";
    }
}


// Resizing logic
function resizeAllCanvases() {
    ctx = setupCanvas(canvas, dpr);
    bgCtx = setupCanvas(bgCanvas, dpr);
    redrawAll();
    if (typeof reapplyBackground === 'function') {
        reapplyBackground(bgCtx); // Optional: restore background visuals
    }
}
window.addEventListener('resize', resizeAllCanvases);
resizeAllCanvases();

function toggleFullscreen() {
    const elem = document.documentElement;
    const isFullscreen = document.fullscreenElement ||
                          document.webkitFullscreenElement ||
                          document.msFullscreenElement;

    const handleResize = () => setTimeout(resizeAllCanvases, 250);

    if (!isFullscreen) {
        // ENTER fullscreen
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
        fulllscreenBtn.textContent = 'Fullscreen On';
    } else {
        // EXIT fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        fulllscreenBtn.textContent = 'Fullscreen Off';
    }

    handleResize();
}


// Device connect logic with QR-Code
function fetchLaptopIP() {
    return fetch('/ip')
        .then(res => res.json())
        .then(data => {
            laptopIP = data.ip;
            console.log("Laptop IP fetched:", laptopIP);
        })
        .catch(err => {
            console.error("Failed to get laptop IP:", err);
        });
}

async function sendDrawingToLaptop() {
    const dataURL = canvas.toDataURL('image/png');
    await fetchLaptopIP(); // Wait for laptopIP to be set

    fetch(`http://${laptopIP}:5000/upload`, {
        method: 'POST',
        body: JSON.stringify({ 
            image: dataURL,
            width: canvas.width / window.devicePixelRatio,
            height: canvas.height / window.devicePixelRatio
        }),
        headers: { 'Content-Type': 'application/json' }
    })
    .then(res => res.json())
    .then(() => {
        alert("Drawing sent successfully");
        toggleFullscreen()
        // Laptop will poll and detect the new drawing
    })
    .catch(err => {
        console.error("Error sending drawing:", err);
        alert("Failed to send to laptop.");
    });
}

async function loadDrawing() {
    try {
        const metaRes = await fetch('/drawing-meta');
        if (!metaRes.ok) throw new Error('No metadata yet');
        const meta = await metaRes.json();
        const { width: ipadWidth, height: ipadHeight } = meta;

        const imgRes = await fetch('/draw');
        if (!imgRes.ok) throw new Error('No drawing yet');
        const blob = await imgRes.blob();

        const img = new Image();
        img.onload = () => {
            // Get device pixel ratio
            const dpr = window.devicePixelRatio || 1;

            // Get canvas size from CSS (visible size)
            const rect = canvas.getBoundingClientRect();

            // Resize canvas to match display size at full resolution
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Get 2D context and scale it for HiDPI
            const ctx = canvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
            ctx.scale(dpr, dpr);

            // Clear canvas before drawing
            ctx.clearRect(0, 0, rect.width, rect.height);

            // Compute scaled image size (use iPad metadata)
            const imgWidth = ipadWidth;
            const imgHeight = ipadHeight;

            // Scale image to match visual pixels
            const scaledWidth = imgWidth / dpr;
            const scaledHeight = imgHeight / dpr;

            // Center the image within the visible canvas
            const x = (rect.width - scaledWidth) / 2;
            const y = (rect.height - scaledHeight) / 2;

            // Draw the image at proper scale and center
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
        };

        img.src = URL.createObjectURL(blob);
    } catch (err) {
        console.log("Waiting for drawing...", err);
    }
}

function pollForNewDrawing() {
  fetch('/new-drawing')
    .then(res => res.json())
    .then(data => {
      if (data.new_drawing) {
        console.log("New drawing detected! Loading...");
        loadDrawing();
      }
    })
    .catch(err => {
      console.error("Error polling for new drawing:", err);
    });
}

function showQRModal() {
    fetch('/qrcode')
        .then(res => res.blob())
        .then(blob => {
            const qrURL = URL.createObjectURL(blob);
            document.getElementById('qr-image').src = qrURL;
            document.getElementById('qr-modal').style.display = 'flex';
        })
        .catch(err => {
            alert("Failed to load QR code: " + err.message);
        });
}

function closeQRModal() {
    document.getElementById('qr-modal').style.display = 'none';
}


// Start polling every 3 seconds (only on laptop)
if (isLaptop()) {
  setInterval(pollForNewDrawing, 3000);
}
</script>
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
</body>
</html>
