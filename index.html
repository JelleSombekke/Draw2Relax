<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Draw2Relax</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #background {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            pointer-events: none;
        }

        #draw {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0);
            padding: 8px;
            border-radius: 8px;
        }
        button {
            font-size: 16px;
            margin-right: 10px;
        }

        .button-styled {
            align-items: center;
            appearance: none;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 24px;
            border-style: none;
            box-shadow: rgba(0, 0, 0, .2) 0 3px 5px -1px,
                        rgba(0, 0, 0, .14) 0 6px 10px 0,
                        rgba(0, 0, 0, .12) 0 1px 18px 0;
            box-sizing: border-box;
            color: #3c4043;
            cursor: pointer;
            display: inline-flex;
            fill: currentcolor;
            font-family: "Google Sans", Roboto, Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            height: 48px;
            justify-content: center;
            letter-spacing: .25px;
            line-height: normal;
            max-width: 100%;
            overflow: visible;
            padding: 2px 24px;
            position: relative;
            text-align: center;
            text-transform: none;
            transition: box-shadow 280ms cubic-bezier(.4, 0, .2, 1),
                        opacity 15ms linear 30ms,
                        transform 270ms cubic-bezier(0, 0, .2, 1) 0ms;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            width: auto;
            will-change: transform, opacity;
            z-index: 0;
        }

        .button-styled:hover {
        background: #F6F9FE;
        color: #174ea6;
        }

        .button-styled:active {
        box-shadow: 0 4px 4px 0 rgb(60 64 67 / 30%), 0 8px 12px 6px rgb(60 64 67 / 15%);
        outline: none;
        }

        .button-styled:not(:disabled) {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        .button-styled:not(:disabled):hover {
        box-shadow: rgba(60, 64, 67, .3) 0 2px 3px 0, rgba(60, 64, 67, .15) 0 6px 10px 4px;
        }

        .button-styled:not(:disabled):focus {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        .button-styled:not(:disabled):active {
        box-shadow: rgba(60, 64, 67, .3) 0 4px 4px 0, rgba(60, 64, 67, .15) 0 8px 12px 6px;
        }

        .button-styled:disabled {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        body.drawing-mode button,
        body.drawing-mode .button-styled {
            pointer-events: none;
            cursor: default !important;
            background: rgba(255, 255, 255, 0.75) !important;
            color: #3c4043 !important;
            box-shadow: rgba(0, 0, 0, .2) 0 1px 1px -1px,
                        rgba(0, 0, 0, .14) 0 2px 4px 0,
                        rgba(0, 0, 0, .12) 0 0px 12px 0 !important;
        }

        /* Loading spinner styles */
        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 20;
        }

        .spinner-border {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        #toggle-mode-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
            z-index: 20;
        }

        #sensor-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 20;
        }

        #status-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
            background-color: red; /* Default: inactive */
        }

        #toggle-fullscreen-btn {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
            z-index: 20;
        }

        body.drawing-mode #toggle-mode-btn,
        body.drawing-mode #sensor-status,
        body.drawing-mode #toggle-fullscreen-btn {
            pointer-events: none;
            cursor: default !important;
            background: rgba(255, 255, 255, 0.75) !important;
            color: #3c4043 !important;
            box-shadow: 0 0 6px rgba(0,0,0,0.1) !important;
        }

        #qr-modal {
            display: none; /* hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 9999;

            display: flex;
            align-items: center;
            justify-content: center;
        }

        #qr-modal > div {
            background: white;
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 90%;
        }

        #qr-modal img {
            max-width: 300px;
            margin: 10px auto;
        }

        #palette-dropdown {
            display: block;
            margin-top: 8px;
            width: fit-content;
            }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-options {
            display: none;
            position: absolute;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 8px 0;
            z-index: 1000;
            min-width: 160px;
            top: 100%;
            left: 0;
            }

        .dropdown-options.open {
            display: block;
        }

        .palette-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
        }

        .palette-option:hover {
            background-color: #f0f0f0;
        }

        .palette-colors {
            display: flex;
            margin-left: auto;
        }

        .palette-swatch {
            width: 16px;
            height: 16px;
            margin-left: 4px;
            border-radius: 50%;
            border: 1px solid #ccc;
        }


    </style>
</head>
<body>

<canvas id="background"></canvas>
<canvas id="draw"></canvas>

<div id="toolbar">
    <button class="button-styled" role="button" onclick="clearCanvas()">Clear</button>
    <button class="button-styled" role="button" onclick="undo()">Undo</button>
    <button class="button-styled" role="button" onclick="submitDrawing()">Submit</button>
    <button class="button-styled" role="button" onclick="simulateBreathing()">Simulate</button>
    <button id="show-qr-btn" class="button-styled" style="display:none;">Connect device</button>

    <div id="palette-dropdown" class="dropdown">
        <button id="palette-toggle-btn" class="button-styled">Palette: <span id="selected-palette">Blues</span></button>
        <div id="dropdown-options" class="dropdown-options"></div>
    </div>

</div>

<button id="toggle-mode-btn">Mousepad Mode: OFF</button>

<button id="toggle-fullscreen-btn" onclick="toggleFullscreen();">Fullscreen Off</button>

<div id="sensor-status">
    <span id="status-text">Breathing Sensor Inactive</span>
    <span id="status-light"></span>
</div>

<div id="spinner" style="
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    background: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 10px;
    z-index: 999;
">
    Processing...
</div>

<!-- QR Modal -->
<div id="qr-modal" style="display:none;">
    <div>
      <h3>Scan this QR with your device</h3>
      <img id="qr-image" src="" alt="QR Code"/>
      <br/>
      <button onclick="closeQRModal()">Close</button>
    </div>
</div>

<script>
let laptopIP = null;

function setupCanvas(canvas, dpr) {
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Set canvas style size (CSS pixels)
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    // Set actual canvas size (scaled for resolution)
    canvas.width = width * dpr;
    canvas.height = height * dpr;

    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Scale all drawings
    return ctx;
}

const dpr = window.devicePixelRatio || 1;
let canvas = document.getElementById('draw');
let ctx = setupCanvas(canvas, dpr);
let bgCanvas = document.getElementById('background');
let bgCtx = setupCanvas(bgCanvas, dpr);
let offscreenCanvas = document.createElement('canvas');
let offscreenCtx = setupCanvas(offscreenCanvas, dpr);

const paletteToggleBtn = document.getElementById("palette-toggle-btn");
const dropdownOptions = document.getElementById("dropdown-options");
const selectedText = document.getElementById("selected-palette");

const palettes = {
    blues: {
        background: [[180, 210, 255], [100, 150, 255], [130, 190, 255], [160, 220, 255]],
        glow:       [[100, 130, 255], [80, 120, 250], [60, 100, 220], [40, 80, 200]]
    },
    reds: {
        background: [[255, 150, 150], [255, 100, 100], [200, 70, 70], [230, 120, 120]],
        glow:       [[255, 100, 180], [200, 50, 130], [150, 30, 100], [220, 90, 150]]
    },
    purples: {
        background: [[220, 200, 255], [200, 180, 255], [160, 130, 255], [120, 90, 220]],
        glow:       [[160, 140, 240], [120, 100, 200], [90, 70, 180], [60, 40, 150]]
    },
    teals: {
        background: [[200, 255, 240], [150, 230, 220], [100, 200, 190], [60, 170, 160]],
        glow:       [[140, 255, 220], [100, 220, 200], [60, 180, 160], [40, 140, 130]]
    },
    ambers: {
        background: [[255, 235, 180], [255, 210, 120], [255, 180, 60], [220, 140, 20]],
        glow:       [[255, 200, 100], [255, 170, 80], [230, 140, 40], [200, 110, 20]]
    },
    forest: {
        background: [[200, 255, 200], [160, 220, 160], [120, 180, 120], [80, 140, 80]],
        glow:       [[140, 230, 140], [100, 190, 100], [70, 150, 70], [50, 110, 50]]
    }
};

let chosenPalette = 'blues';
let paletteDropdownOpen = false;

// Populate dropdown options
Object.entries(palettes).forEach(([name, colors]) => {
  const option = document.createElement("div");
  option.className = "palette-option";
  option.dataset.palette = name;
  option.innerHTML = `
    ${name.charAt(0).toUpperCase() + name.slice(1)}
    <div class="palette-colors">
      ${colors.background.map(([r, g, b]) =>
        `<div class="palette-swatch" style="background: rgb(${r},${g},${b})"></div>`
      ).join('')}
    </div>
  `;

  option.addEventListener("click", () => {
    chosenPalette = name;
    selectedText.textContent = name.charAt(0).toUpperCase() + name.slice(1);
    closeDropdown();
  });

  dropdownOptions.appendChild(option);
});

// Toggle dropdown
paletteToggleBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (paletteToggleBtn.disabled) return;

  paletteDropdownOpen = !paletteDropdownOpen;
  dropdownOptions.classList.toggle("open", paletteDropdownOpen);
});

// Close on outside click or touch
document.addEventListener("click", () => closeDropdown());
document.addEventListener("touchstart", (e) => {
  if (paletteDropdownOpen && !dropdownOptions.contains(e.target) && e.target !== paletteToggleBtn) {
    closeDropdown();
  }
});

function closeDropdown() {
  paletteDropdownOpen = false;
  dropdownOptions.classList.remove("open");
}


const submitBtn = document.querySelector('button[onclick="submitDrawing()"]');
const clearBtn = document.querySelector('button[onclick="clearCanvas()"]');
const undoBtn = document.querySelector('button[onclick="undo()"]');
const spinnerBlock = document.getElementById('spinner')
const simulateBtn = document.querySelector('button[onclick="simulateBreathing()"]');
const toggleBtn = document.getElementById("toggle-mode-btn")
const connectBtn = document.getElementById('show-qr-btn');

let framePaths = []; 
let drawing = false;
let isDrawingDisabled = false;
let mousepadMode = false;
let currentPath = [];
let submitted = false;
let paths = [];
let animationFrameId = null;
let breathingSensorActive = false;
let previousBreathingValue = 0;
let currentBreathingValue = 0;
let global_index = 0
let isAnimating = false;
let isAnimatingBackground = false;
let breathingIntervalId = null;
let simulationIntervalId = null;
let breathingDirection = "up"; // or "down"
let previousValues = [];
const maxWindowSize = 20;
let peakDetected = false;
let valleyDetected = false;
let frameImages = [];
let colorCounter = 0;
let startColor = [255, 255, 255];
let prevColor = [255, 255, 255];
let startGlowColor = [255, 255, 255];
let prevGlowColor = [255, 255, 255];
let blackPixels = null;

const toggleModeBtn = document.getElementById('toggle-mode-btn');
toggleModeBtn.addEventListener('click', () => {
    mousepadMode = !mousepadMode;
    toggleModeBtn.textContent = mousepadMode ? "Mousepad Mode: ON" : "Mousepad Mode: OFF";
});

window.addEventListener('DOMContentLoaded', () => {
  const qrBtn = document.getElementById('show-qr-btn');
  if (isLaptop()) {
    qrBtn.addEventListener('click', showQRModal);
    toggleBtn.style.display = 'inline-block';
    qrBtn.style.display = 'inline-block';
    paletteToggleBtn.style.display = 'inline-block';
    simulateBtn.style.display = 'inline-block';
  } else {
    toggleBtn.style.display = 'none';
    qrBtn.style.display = 'none';
    paletteToggleBtn.style.display = 'none';
    simulateBtn.style.display = 'none';
  }
});

window.addEventListener("beforeunload", (event) => {
    // Send a background POST to clear frames
    navigator.sendBeacon('/clear-frames');

    // Optionally reset your local state
    colorCounter = 0;
    startColor = [255, 255, 255];
    prevColor = [255, 255, 255];
    startGlowColor = [255, 255, 255];
    prevGlowColor = [255, 255, 255];
    blackPixels = null;
    frameImages = [];


    if (breathingIntervalId !== null) {
        clearInterval(breathingIntervalId);
        breathingIntervalId = null;
    }

    if (simulationIntervalId !== null) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }

    if (breathingSensorActive){
        fetch('/stop-sensor', {
            method: 'POST',
            body: JSON.stringify({}),
            headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(response => {
            breathingSensorActive = false;
            updateSensorStatus();
        })
        .catch(err => {
            console.error('Error during sensor deactivating:', err);
            alert("Something went wrong. Please try again.");
        })
    }
});
// Mouse
canvas.addEventListener('mousedown', startDrawing);
window.addEventListener('mousemove', drawMove);
window.addEventListener('mouseup', stopDrawing);

// Touch
canvas.addEventListener('touchstart', startDrawing, { passive: false });
canvas.addEventListener('touchmove', drawMove, { passive: false });
canvas.addEventListener('touchend', stopDrawing);

document.addEventListener('fullscreenchange', () => {
  const button = document.getElementById('toggle-fullscreen-btn');
  if (!document.fullscreenElement) {
    button.textContent = 'Fullscreen Off';
  } else {
    button.textContent = 'Fullscreen On';
  }
});

function isIOS() {
  const ua = navigator.userAgent || navigator.vendor || window.opera;
  return /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
}

// Optional: You can also check for iPadOS 13+ (which reports as Mac but with touch)
function isIPadOS() {
  return (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}

function isLaptop() {
  // Laptop = Not iOS, not iPadOS, not any mobile device
  return !isIOS() && !isIPadOS() && !/Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

function getPointFromEvent(e) {
    if (e.touches) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else {
        return { x: e.clientX, y: e.clientY };
    }
}

// ---- START DRAWING ----
function startDrawing(e) {
    if (isDrawingDisabled) return;
    const point = getPointFromEvent(e);

    if (mousepadMode) {
        if (drawing) {
            drawing = false;
            if (currentPath.length > 0) {
                paths.push(currentPath);
                currentPath = [];
            }
            submitBtn.disabled = false;
            clearBtn.disabled = false;
            undoBtn.disabled = false;
            simulateBtn.disabled = false;
            connectBtn.disabled = false;
            paletteToggleBtn.disabled = false;
            document.body.classList.remove('drawing-mode');
        } else {
            drawing = true;
            currentPath = [point];
            submitBtn.disabled = true;
            clearBtn.disabled = true;
            undoBtn.disabled = true;
            simulateBtn.disabled = true;
            connectBtn.disabled = true;
            paletteToggleBtn.disabled = true;
            document.body.classList.add('drawing-mode');
        }
    } else {
        drawing = true;
        currentPath = [point];
        document.body.classList.add('drawing-mode');
    }

    e.preventDefault();
}

// ---- STOP DRAWING ----
function stopDrawing(e) {
    if (isDrawingDisabled) return;
    if (!mousepadMode && drawing) {
        drawing = false;
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;
        document.body.classList.remove('drawing-mode');
        if (currentPath.length > 0) {
            paths.push(currentPath);
            currentPath = [];
        }
    }
    e.preventDefault();
}

// ---- DRAW MOVE ----
function drawMove(e) {
    if (isDrawingDisabled || !drawing) return;
    const point = getPointFromEvent(e);
    currentPath.push(point);

    submitBtn.disabled = true;
    clearBtn.disabled = true;
    undoBtn.disabled = true;
    simulateBtn.disabled = true;
    connectBtn.disabled = true;
    paletteToggleBtn.disabled = true;

    if (currentPath.length > 1) {
        const prev = currentPath[currentPath.length - 2];
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
    }

    e.preventDefault();
}


// Function to fetch sensor data from the Flask backend
function fetchBreathingData() {
    fetch('/get-breathing-data')
        .then(res => res.json())
        .then(data => {
            const breathingValue = data.breathing_value;

            // Keep original direction logic
            const direction = (breathingValue > previousBreathingValue) ? "up"
                             : (breathingValue < previousBreathingValue) ? "down"
                             : breathingDirection;

            breathingDirection = direction;
            previousBreathingValue = breathingValue;

            // Normalize and map to frame index
            const minVal = 70;
            const maxVal = 160;
            const normalized = Math.max(0, Math.min(1, (breathingValue - minVal) / (maxVal - minVal)));
            const index = Math.floor(normalized * (framePaths.length - 1));
            console.log("Image index:", index);
            showFrameAtIndex(index);

            // Peak/trough detection
            previousValues.push(breathingValue);
            if (previousValues.length > maxWindowSize) previousValues.shift();

            if (previousValues.length === maxWindowSize) {
                const midIndex = Math.floor(maxWindowSize / 2);
                const midValue = previousValues[midIndex];

                const isPeak = previousValues.every((v, i) => i === midIndex || v < midValue);
                const isValley = previousValues.every((v, i) => i === midIndex || v > midValue);

                if (isPeak && !peakDetected) {
                    peakDetected = true;
                    valleyDetected = false;
                    updateColorCycle(); // Inhale peak
                } else if (isValley && !valleyDetected) {
                    valleyDetected = true;
                    peakDetected = false;
                    updateColorCycle(); // Exhale bottom
                }
            }

        })
        .catch(err => console.error('Error fetching breathing data:', err));
}


function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    paths = [];
    currentPath = [];

    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);

    if (breathingIntervalId !== null) {
        clearInterval(breathingIntervalId);
        breathingIntervalId = null;
    }
    if (simulationIntervalId !== null) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }

    submitBtn.style.display = 'inline-block';
    undoBtn.style.display = 'inline-block';
    if (isLaptop()) {
        toggleBtn.style.display = "inline-block";
        simulateBtn.style.display = 'inline-block';
        connectBtn.style.display = "inline-block";
        paletteToggleBtn.style.display = "inline-block";
    }
    fetch('/clear-frames', {
        method: 'POST'
    })
    .then(res => {
        if (!res.ok) throw new Error('Failed to clear server frames');
    })
    .catch(err => {
        console.error('Error clearing frames:', err);
    });

    submitted = false;
    isDrawingDisabled = false;
    isAnimatingBackground = false;
    colorCounter = 0;
    startColor = [255, 255, 255];
    prevColor = [255, 255, 255];
    startGlowColor = [255, 255, 255];
    prevGlowColor = [255, 255, 255];
    blackPixels = null;
    frameImages = [];

    if (breathingSensorActive){
        fetch('/stop-sensor', {
            method: 'POST',
            body: JSON.stringify({}),
            headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(response => {
            breathingSensorActive = false;
            updateSensorStatus();
        })
        .catch(err => {
            console.error('Error during sensor deactivating:', err);
            alert("Something went wrong. Please try again.");
    })
    }
}

function undo() {
    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animateBackgroundColor([255, 255, 255], [255, 255, 255], 1)
    }
    
    if (paths.length > 0) {
        paths.pop(); // Remove last stroke
        redrawAll();
    }
    

    if (submitted) {
        fetch('/clear-frames', {
            method: 'POST'
        })
        .then(res => {
            if (!res.ok) throw new Error('Failed to clear server frames');
        })
        .catch(err => {
            console.error('Error clearing frames:', err);
        });

        submitted = false;
        isDrawingDisabled = false;
        colorCounter = 0;
        startColor = [255, 255, 255];
        prevColor = [255, 255, 255];
        startGlowColor = [255, 255, 255];
        prevGlowColor = [255, 255, 255];
        blackPixels = null;
        frameImages = [];
    }
}

function redrawAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'black';

    for (let path of paths) {
        for (let i = 1; i < path.length; i++) {
            ctx.beginPath();
            ctx.moveTo(path[i - 1].x, path[i - 1].y);
            ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
        }
    }
}


function preloadFrames() {
    return Promise.all(frameImages = framePaths.map((base64, i) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = `data:image/png;base64,${base64}`;

            img.onload = () => {
                // Draw at natural image size to preserve pixel integrity
                offscreenCanvas.width = img.width;
                offscreenCanvas.height = img.height;
                offscreenCtx.drawImage(img, 0, 0, img.width, img.height);

                const imageData = offscreenCtx.getImageData(0, 0, img.width, img.height);
                const minStep = 6;
                const maxStep = 4;
                const totalFrames = framePaths.length;

                // Linearly interpolate step size
                const sampleStep = Math.round(
                    maxStep - ((maxStep - minStep) * (i / (totalFrames - 1)))
                );

                const blackPixels = [];

                for (let y = 0; y < img.height; y += sampleStep) {
                    for (let x = 0; x < img.width; x += sampleStep) {
                        const idx = (y * img.width + x) * 4;
                        const r = imageData.data[idx];
                        const g = imageData.data[idx + 1];
                        const b = imageData.data[idx + 2];
                        const a = imageData.data[idx + 3];

                        if (r < 50 && g < 50 && b < 50 && a > 50) {
                            blackPixels.push({ x, y });
                        }
                    }
                }

                img.blackPixelsCache = blackPixels;
                resolve(img);
            };
        });
    }));
}


function submitDrawing() {
    if (!isLaptop()) {
        sendDrawingToLaptop(); // Don't process locally on device
        alert("Drawing sent to laptop for processing.");
        return;
    }

    const dataURL = canvas.toDataURL('image/png');
    submitted = true;

    submitBtn.disabled = true;
    clearBtn.disabled = true;
    undoBtn.disabled = true;
    simulateBtn.disabled = true
    connectBtn.disabled = true;
    paletteToggleBtn.disabled = true;
    isDrawingDisabled = true
    spinnerBlock.style.display = 'block';

    fetch('/process', {
        method: 'POST',
        body: JSON.stringify({ image: dataURL }),
        headers: { 'Content-Type': 'application/json' }
    })
    .then(res => res.json())
    .then(response => {
        framePaths = response.frames;
        return preloadFrames();
    })
    .then(loadedImages => {
        frameImages = loadedImages;

        framePaths = response.frames;
        preloadFrames();

        spinnerBlock.style.display = 'none';
        submitBtn.style.display = 'none';
        undoBtn.style.display = 'none';
        toggleBtn.style.display = "none";
        simulateBtn.style.display = "none";
        connectBtn.style.display = "none";
        paletteToggleBtn.disabled =  "none";

        showFrameAtIndex(0);
        
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;

        fetch('/run-sensor', {
            method: 'POST',
            body: JSON.stringify({}),
            headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(response => {
            breathingSensorActive = true;
            updateSensorStatus();
            breathingIntervalId = setInterval(fetchBreathingData, 200);
        })
        .catch(err => {
            console.error('Error during sensor activating:', err);
            spinnerBlock.style.display = 'none';
            submitBtn.disabled = false;
            clearBtn.disabled = false;
            undoBtn.disabled = false;
            simulateBtn.disabled = false
            connectBtn.disabled = false;
            paletteToggleBtn.disabled = false;
    
            isDrawingDisabled = false
            alert("Something went wrong. Please try again.");
        })
    })
    .catch(err => {
        console.error('Error during image processing:', err);
        spinnerBlock.style.display = 'none';
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;

        isDrawingDisabled = false
        alert("Something went wrong. Please try again.");
    });
}

function simulateBreathing() {
    const dataURL = canvas.toDataURL('image/png');
    submitted = true;

    submitBtn.disabled = true;
    clearBtn.disabled = true;
    undoBtn.disabled = true;
    simulateBtn.disabled = true;
    connectBtn.disabled = true;
    paletteToggleBtn.disabled = true;

    isDrawingDisabled = true;
    spinnerBlock.style.display = 'block';

    fetch('/process', {
        method: 'POST',
        body: JSON.stringify({ image: dataURL }),
        headers: { 'Content-Type': 'application/json' }
    })
    .then(res => res.json())
    .then(response => {
        framePaths = response.frames;
        return preloadFrames();
    })
    .then(loadedImages => {
        frameImages = loadedImages;

        spinnerBlock.style.display = 'none';
        submitBtn.style.display = 'none';
        undoBtn.style.display = 'none';
        simulateBtn.style.display = 'none';
        toggleBtn.style.display = "none";
        connectBtn.style.display = "none";
        paletteToggleBtn.style.display = "none";

        showFrameAtIndex(0);

        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;

        // --- Simulation Setup ---
        const n_frames = framePaths.length;
        const duration_sec = 100;
        const sampling_rate = 200;
        const total_samples = duration_sec * sampling_rate;

        const breathing_rate_per_min = 30; // You can adjust this
        const breath_cycles = (breathing_rate_per_min / 60) * duration_sec;

        const minVal = 70;
        const maxVal = 160;

        const t_interp = Array.from({ length: total_samples }, (_, i) => i / sampling_rate);
        const freq = breath_cycles / duration_sec; // cycles per second
        const rr_interp = t_interp.map(t => Math.sin(2 * Math.PI * freq * t));

        const min = Math.min(...rr_interp);
        const max = Math.max(...rr_interp);
        const rr_norm = rr_interp.map(v => (v - min) / (max - min)); // Normalize to [0, 1]

        let i = 0;
        const delay = 2000 / sampling_rate;

        previousBreathingValue = 0;
        previousValues = [];
        peakDetected = false;
        valleyDetected = false;

        simulationIntervalId = setInterval(() => {
            if (i >= rr_norm.length) {
                clearInterval(simulationIntervalId);
                simulationIntervalId = null;
                console.log("Done with simulation");
                return;
            }

            const normalized = rr_norm[i];
            const breathingValue = normalized * (maxVal - minVal) + minVal;

            const direction = (breathingValue > previousBreathingValue) ? "up"
                             : (breathingValue < previousBreathingValue) ? "down"
                             : breathingDirection;
            breathingDirection = direction;
            previousBreathingValue = breathingValue;

            const index = Math.floor(normalized * (n_frames - 1));
            showFrameAtIndex(index);

            // Peak/trough detection
            previousValues.push(breathingValue);
            if (previousValues.length > maxWindowSize) previousValues.shift();

            if (previousValues.length === maxWindowSize) {
                const midIndex = Math.floor(maxWindowSize / 2);
                const midValue = previousValues[midIndex];

                const isPeak = previousValues.every((v, i) => i === midIndex || v < midValue);
                const isValley = previousValues.every((v, i) => i === midIndex || v > midValue);

                if (isPeak && !peakDetected) {
                    peakDetected = true;
                    valleyDetected = false;
                    updateColorCycle(); // Inhale peak
                } else if (isValley && !valleyDetected) {
                    valleyDetected = true;
                    peakDetected = false;
                    updateColorCycle(); // Exhale bottom
                }
            }

            i++;
        }, delay);
    })
    .catch(err => {
        console.error('Error during image processing:', err);
        spinnerBlock.style.display = 'none';
        submitBtn.disabled = false;
        clearBtn.disabled = false;
        undoBtn.disabled = false;
        simulateBtn.disabled = false;
        connectBtn.disabled = false;
        paletteToggleBtn.disabled = false;

        isDrawingDisabled = false;
        alert("Something went wrong. Please try again.");
    });
}


function showFrameAtIndex(targetIndex) {
    if (!frameImages.length || targetIndex < 0 || targetIndex >= frameImages.length) return;
    if (isAnimating || targetIndex === global_index) return;

    isAnimating = true;

    const step = (targetIndex > global_index) ? 1 : -1;

    function animateStep() {
        global_index += step;

        const img = frameImages[global_index];
        if (!img.complete) {
            // If image isn't loaded yet, wait and retry
            setTimeout(animateStep, 5);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
        animateBackgroundColor(targetIndex, prevColor, startColor, 5000);

        if (global_index !== targetIndex) {
            setTimeout(animateStep, 10); // smooth step
        } else {
            isAnimating = false;
        }
    }

    animateStep();
}

function getDoodleLength() {
    let length = 0;
    paths.forEach(path => {
        for (let i = 1; i < path.length; i++) {
            const dx = path[i].x - path[i - 1].x;
            const dy = path[i].y - path[i - 1].y;
            length += Math.sqrt(dx * dx + dy * dy);
        }
    });
    return length;
}

function updateColorCycle() {
    const paletteObj = palettes[chosenPalette]
    const bgPalette = paletteObj.background;
    const glowPalette = paletteObj.glow;

    const blendFactor = 0.05;

    // Background color update
    const nextColor = bgPalette[colorCounter % bgPalette.length];
    prevColor = [...startColor];
    startColor = [
        Math.round(startColor[0] * (1 - blendFactor) + nextColor[0] * blendFactor),
        Math.round(startColor[1] * (1 - blendFactor) + nextColor[1] * blendFactor),
        Math.round(startColor[2] * (1 - blendFactor) + nextColor[2] * blendFactor)
    ];

    // Glow color update (from separate palette)
    const nextGlowColor = glowPalette[colorCounter % glowPalette.length];
    prevGlowColor = [...startGlowColor];
    startGlowColor = [
        Math.round(startGlowColor[0] * (1 - blendFactor) + nextGlowColor[0] * blendFactor),
        Math.round(startGlowColor[1] * (1 - blendFactor) + nextGlowColor[1] * blendFactor),
        Math.round(startGlowColor[2] * (1 - blendFactor) + nextGlowColor[2] * blendFactor)
    ];

    colorCounter++;
}

function createGlowStamp(color, radius) {
    const size = radius * 2;
    const glowCanvas = document.createElement('canvas');
    glowCanvas.width = glowCanvas.height = size;
    const glowCtx = glowCanvas.getContext('2d');

    const [r, g, b] = color;
    const gradient = glowCtx.createRadialGradient(
        radius, radius, 0,
        radius, radius, radius
    );
    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

    glowCtx.fillStyle = gradient;
    glowCtx.fillRect(0, 0, size, size);

    return glowCanvas;
}

function animateBackgroundColor(targetIndex, startColor, endColor, duration = 5000) {
    const doodleImg = frameImages[targetIndex];
    if (!doodleImg || !doodleImg.complete || !doodleImg.blackPixelsCache) {
        setTimeout(() => animateBackgroundColor(targetIndex, startColor, endColor, duration), 10);
        return;
    }

    blackPixels = doodleImg.blackPixelsCache;
    let startTime = null;
    isAnimatingBackground = true;

    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    function drawLayeredStrokes(color, layerCount = 2, radius = 15) {
        bgCtx.save();
        bgCtx.globalAlpha = 0.9;
        radius = radius * (targetIndex / (framePaths.length - 1)) + 5

        const adjustedRadius = radius * dpr;
        const glowStamp = createGlowStamp(color, adjustedRadius);

        for (let l = 0; l < layerCount; l++) {
            const offsetX = Math.sin(l * 0.5) * 10;
            const offsetY = Math.cos(l * 0.5) * 10;

            blackPixels.forEach(({ x, y }) => {
                const sx = (x + offsetX) / dpr;
                const sy = (y + offsetY) / dpr;

                bgCtx.drawImage(glowStamp, sx - adjustedRadius, sy - adjustedRadius);
            });
        }
        bgCtx.restore();
    }


    function animate(time) {
        if (!isAnimatingBackground) return;
        if (!startTime) startTime = time;

        const elapsed = time - startTime;
        const t = Math.min(elapsed / duration, 1);

        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);

        // Interpolate glow color ahead of background
        const glowR = Math.round(prevGlowColor[0] + (startGlowColor[0] - prevGlowColor[0]) * t);
        const glowG = Math.round(prevGlowColor[1] + (startGlowColor[1] - prevGlowColor[1]) * t);
        const glowB = Math.round(prevGlowColor[2] + (startGlowColor[2] - prevGlowColor[2]) * t);
        const glowColor = [glowR, glowG, glowB];

        // Interpolate background color normally
        const bgR = Math.round(startColor[0] + (endColor[0] - startColor[0]) * t);
        const bgG = Math.round(startColor[1] + (endColor[1] - startColor[1]) * t);
        const bgB = Math.round(startColor[2] + (endColor[2] - startColor[2]) * t);

        // Fill background with interpolated color
        bgCtx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

        drawLayeredStrokes(glowColor);

        if (t < 1) {
            animationFrameId = requestAnimationFrame(animate);
        } else {
            isAnimatingBackground = false;
        }
    }
    animationFrameId = requestAnimationFrame(animate);
}

function updateSensorStatus() {
    const statusText = document.getElementById("status-text");
    const statusLight = document.getElementById("status-light");

    if (breathingSensorActive) {
        statusText.textContent = "Breathing Sensor Active";
        statusLight.style.backgroundColor = "green";
    } else {
        statusText.textContent = "Breathing Sensor Inactive";
        statusLight.style.backgroundColor = "red";
    }
}


function resizeAllCanvases() {
    ctx = setupCanvas(canvas, dpr);
    bgCtx = setupCanvas(bgCanvas, dpr);
    redrawAll();
    if (typeof reapplyBackground === 'function') {
        reapplyBackground(bgCtx); // Optional: restore background visuals
    }
}
window.addEventListener('resize', resizeAllCanvases);
resizeAllCanvases();

function toggleFullscreen() {
    const elem = document.documentElement;
    const button = document.getElementById('toggle-fullscreen-btn');
    const isFullscreen = document.fullscreenElement ||
                          document.webkitFullscreenElement ||
                          document.msFullscreenElement;

    const handleResize = () => setTimeout(resizeAllCanvases, 250);

    if (!isFullscreen) {
        // ENTER fullscreen
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
        button.textContent = 'Fullscreen On';
    } else {
        // EXIT fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        button.textContent = 'Fullscreen Off';
    }

    handleResize();
}


function fetchLaptopIP() {
    return fetch('/ip')
        .then(res => res.json())
        .then(data => {
            laptopIP = data.ip;
            console.log("Laptop IP fetched:", laptopIP);
        })
        .catch(err => {
            console.error("Failed to get laptop IP:", err);
        });
}

async function sendDrawingToLaptop() {
    const dataURL = canvas.toDataURL('image/png');
    await fetchLaptopIP(); // Wait for laptopIP to be set

    fetch(`http://${laptopIP}:5000/upload`, {
        method: 'POST',
        body: JSON.stringify({ 
            image: dataURL,
            width: canvas.width / window.devicePixelRatio,
            height: canvas.height / window.devicePixelRatio
        }),
        headers: { 'Content-Type': 'application/json' }
    })
    .then(res => res.json())
    .then(() => {
        alert("Drawing sent successfully");
        toggleFullscreen()
        // Laptop will poll and detect the new drawing
    })
    .catch(err => {
        console.error("Error sending drawing:", err);
        alert("Failed to send to laptop.");
    });
}

async function loadDrawing() {
    try {
        const metaRes = await fetch('/drawing-meta');
        if (!metaRes.ok) throw new Error('No metadata yet');
        const meta = await metaRes.json();
        const { width: ipadWidth, height: ipadHeight } = meta;

        const imgRes = await fetch('/draw');
        if (!imgRes.ok) throw new Error('No drawing yet');
        const blob = await imgRes.blob();

        const img = new Image();
        img.onload = () => {
            // Get device pixel ratio
            const dpr = window.devicePixelRatio || 1;

            // Get canvas size from CSS (visible size)
            const rect = canvas.getBoundingClientRect();

            // Resize canvas to match display size at full resolution
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Get 2D context and scale it for HiDPI
            const ctx = canvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
            ctx.scale(dpr, dpr);

            // Clear canvas before drawing
            ctx.clearRect(0, 0, rect.width, rect.height);

            // Compute scaled image size (use iPad metadata)
            const imgWidth = ipadWidth;
            const imgHeight = ipadHeight;

            // Scale image to match visual pixels
            const scaledWidth = imgWidth / dpr;
            const scaledHeight = imgHeight / dpr;

            // Center the image within the visible canvas
            const x = (rect.width - scaledWidth) / 2;
            const y = (rect.height - scaledHeight) / 2;

            // Draw the image at proper scale and center
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
        };

        img.src = URL.createObjectURL(blob);
    } catch (err) {
        console.log("Waiting for drawing...", err);
    }
}

function pollForNewDrawing() {
  fetch('/new-drawing')
    .then(res => res.json())
    .then(data => {
      if (data.new_drawing) {
        console.log("New drawing detected! Loading...");
        loadDrawing();
      }
    })
    .catch(err => {
      console.error("Error polling for new drawing:", err);
    });
}

function showQRModal() {
    fetch('/qrcode')
        .then(res => res.blob())
        .then(blob => {
            const qrURL = URL.createObjectURL(blob);
            document.getElementById('qr-image').src = qrURL;
            document.getElementById('qr-modal').style.display = 'flex';
        })
        .catch(err => {
            alert("Failed to load QR code: " + err.message);
        });
}

function closeQRModal() {
    document.getElementById('qr-modal').style.display = 'none';
}


// Start polling every 3 seconds (only on laptop)
if (isLaptop()) {
  setInterval(pollForNewDrawing, 3000);
}
</script>
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
</body>
</html>
